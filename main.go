package main

import (
	"fmt"
	"os"

	"io"
	"strings"

	"bytes"

	yaegi_template "github.com/Eun/yaegi-template"
	"github.com/containous/yaegi/interp"
	"github.com/containous/yaegi/stdlib"
	"gopkg.in/alecthomas/kingpin.v2"
)

var (
	templatingFlag = kingpin.Flag("template", "enable templating").Short('t').Bool()
	writeToFile    = kingpin.Flag("out", "write output to file").Short('o').String()
	goFilesArg     = kingpin.Arg("go file", ".go file to run").Strings()
)

// generated by goreleaser
var version string
var commit string
var date string

func main() {
	kingpin.Version(fmt.Sprintf("%s %s %s", version, commit, date))
	kingpin.Parse()

	t := yaegi_template.MustNew(interp.Options{
		GoPath: os.Getenv("GOPATH"),
	}, stdlib.Symbols)
	if !*templatingFlag {
		t.StartTokens = []rune{}
		t.EndTokens = []rune{}
	}

	amountOfGoFiles := len(*goFilesArg)
	if amountOfGoFiles <= 0 {
		return
	}

	var w io.Writer = os.Stdout
	if writeToFile != nil && *writeToFile != "" {
		f, err := os.Create(*writeToFile)
		if err != nil {
			fmt.Fprintf(os.Stderr, "unable to write file `%s': %v\n", *writeToFile, err)
			os.Exit(1)
		}
		defer f.Close()
		w = f
	}

	for _, file := range *goFilesArg {
		f, err := os.Open(file)
		if err != nil {
			fmt.Fprintf(os.Stderr, "unable to read file `%s': %v\n", file, err)
			os.Exit(1)
		}

		if err = skipShebang(f); err != nil {
			_ = f.Close()
			fmt.Fprintf(os.Stderr, "unable to skip shebang in file `%s': %v\n", file, err)
			os.Exit(1)
		}

		if err = t.Parse(f); err != nil {
			_ = f.Close()
			fmt.Fprintf(os.Stderr, "unable to parse file `%s': %v\n", file, err)
			os.Exit(1)
		}

		if _, err = t.Exec(w, nil); err != nil {
			_ = f.Close()
			fmt.Fprintf(os.Stderr, "unable to exec file `%s': %v\n", file, err)
			os.Exit(1)
		}
		f.Close()
	}
}

func skipShebang(rws io.ReadWriteSeeker) error {
	var buf [128]byte
	var firstLine bytes.Buffer
	for {
		n, err := rws.Read(buf[:])
		if n <= 0 {
			if err == nil {
				return io.ErrUnexpectedEOF
			}
			if err == io.EOF {
				break
			}
			return err
		}
		firstLine.Write(buf[:n])
		if bytes.ContainsRune(buf[:n], '\n') {
			break
		}
	}
	if strings.HasPrefix(firstLine.String(), "#!") {
		// seek to the first \n
		newLine := bytes.IndexRune(firstLine.Bytes(), '\n')
		_, err := rws.Seek(int64(newLine), io.SeekStart)
		return err
	}
	_, err := rws.Seek(0, io.SeekStart)
	return err
}
